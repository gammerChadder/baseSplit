import UniversalProvider from '@walletconnect/universal-provider';
import * as ethers from 'ethers';
import { formatEther } from 'ethers/lib/utils.js';
import { WcConstantsUtil } from '@reown/appkit';
import { ConstantsUtil as CommonConstantsUtil, ParseUtil } from '@reown/appkit-common';
import { AccountController, CoreHelperUtil, StorageUtil } from '@reown/appkit-controllers';
import { ConstantsUtil, PresetsUtil } from '@reown/appkit-utils';
import { ProviderUtil } from '@reown/appkit-utils';
import { EthersHelpersUtil } from '@reown/appkit-utils/ethers';
import { AdapterBlueprint } from '@reown/appkit/adapters';
import { WalletConnectConnector } from '@reown/appkit/connectors';
import { Ethers5Methods } from './utils/Ethers5Methods.js';
export class Ethers5Adapter extends AdapterBlueprint {
    constructor() {
        super({
            adapterType: CommonConstantsUtil.ADAPTER_TYPES.ETHERS5,
            namespace: CommonConstantsUtil.CHAIN.EVM
        });
        this.balancePromises = {};
        this.providerHandlers = null;
    }
    async createEthersConfig(options) {
        if (!options.metadata) {
            return undefined;
        }
        let injectedProvider = undefined;
        function getInjectedProvider() {
            if (injectedProvider) {
                return injectedProvider;
            }
            if (typeof window === 'undefined') {
                return undefined;
            }
            if (!window.ethereum) {
                return undefined;
            }
            injectedProvider = window.ethereum;
            return injectedProvider;
        }
        async function getCoinbaseProvider() {
            try {
                const { createCoinbaseWalletSDK } = await import('@coinbase/wallet-sdk');
                if (typeof window === 'undefined') {
                    return undefined;
                }
                const coinbaseSdk = createCoinbaseWalletSDK({
                    appName: options?.metadata?.name,
                    appLogoUrl: options?.metadata?.icons[0],
                    appChainIds: options.networks?.map(caipNetwork => caipNetwork.id) || [1, 84532],
                    preference: {
                        options: options.coinbasePreference ?? 'all'
                    }
                });
                return coinbaseSdk.getProvider();
            }
            catch (error) {
                console.error('Failed to import Coinbase Wallet SDK:', error);
                return undefined;
            }
        }
        const providers = { metadata: options.metadata };
        if (options.enableInjected !== false) {
            providers.injected = getInjectedProvider();
        }
        if (options.enableCoinbase !== false) {
            const coinbaseProvider = await getCoinbaseProvider();
            if (coinbaseProvider) {
                providers.coinbase = coinbaseProvider;
            }
        }
        providers.EIP6963 = options.enableEIP6963 !== false;
        return providers;
    }
    async signMessage(params) {
        const { message, address, provider } = params;
        if (!provider) {
            throw new Error('Provider is undefined');
        }
        try {
            const signature = await Ethers5Methods.signMessage(message, provider, address);
            return { signature };
        }
        catch (error) {
            throw new Error('EthersAdapter:signMessage - Sign message failed');
        }
    }
    async sendTransaction(params) {
        if (!params.provider) {
            throw new Error('Provider is undefined');
        }
        const tx = await Ethers5Methods.sendTransaction({
            value: Number.isNaN(Number(params.value)) ? BigInt(0) : BigInt(params.value),
            to: params.to,
            data: params.data ? params.data : '0x',
            gas: params.gas ? BigInt(params.gas) : undefined,
            gasPrice: params.gasPrice ? BigInt(params.gasPrice) : undefined,
            address: AccountController.state.address
        }, params.provider, AccountController.state.address, Number(params.caipNetwork?.id));
        return { hash: tx };
    }
    async writeContract(params) {
        if (!params.provider) {
            throw new Error('Provider is undefined');
        }
        const { address } = ParseUtil.parseCaipAddress(params.caipAddress);
        const result = await Ethers5Methods.writeContract(params, params.provider, address, Number(params.caipNetwork?.id));
        return { hash: result };
    }
    async estimateGas(params) {
        const { provider, caipNetwork, address } = params;
        if (!provider) {
            throw new Error('Provider is undefined');
        }
        try {
            const result = await Ethers5Methods.estimateGas({
                data: params.data,
                to: params.to,
                address: address
            }, provider, address, Number(caipNetwork?.id));
            return { gas: result };
        }
        catch (error) {
            throw new Error('EthersAdapter:estimateGas - Estimate gas failed');
        }
    }
    parseUnits(params) {
        return Ethers5Methods.parseUnits(params.value, params.decimals);
    }
    formatUnits(params) {
        return Ethers5Methods.formatUnits(params.value, params.decimals);
    }
    async syncConnection(params) {
        const { id, chainId } = params;
        const connector = this.connectors.find(c => c.id === id);
        const selectedProvider = connector?.provider;
        if (!selectedProvider) {
            throw new Error('Provider not found');
        }
        const accounts = await selectedProvider.request({
            method: 'eth_requestAccounts'
        });
        const requestChainId = await selectedProvider.request({
            method: 'eth_chainId'
        });
        this.listenProviderEvents(selectedProvider);
        if (!accounts[0]) {
            throw new Error('No accounts found');
        }
        if (!connector?.type) {
            throw new Error('Connector type not found');
        }
        return {
            address: accounts[0],
            chainId: Number(requestChainId) || Number(chainId),
            provider: selectedProvider,
            type: connector.type,
            id
        };
    }
    async syncConnectors(options) {
        this.ethersConfig = await this.createEthersConfig(options);
        if (this.ethersConfig?.EIP6963) {
            this.listenInjectedConnector(true);
        }
        const connectors = Object.keys(this.ethersConfig || {}).filter(key => key !== 'metadata' && key !== 'EIP6963');
        connectors.forEach(connector => {
            const key = connector === 'coinbase' ? 'coinbaseWalletSDK' : connector;
            const isInjectedConnector = connector === CommonConstantsUtil.CONNECTOR_ID.INJECTED;
            if (this.namespace) {
                this.addConnector({
                    id: key,
                    explorerId: PresetsUtil.ConnectorExplorerIds[key],
                    imageUrl: options?.connectorImages?.[key],
                    name: PresetsUtil.ConnectorNamesMap[key] || 'Unknown',
                    imageId: PresetsUtil.ConnectorImageIds[key],
                    type: PresetsUtil.ConnectorTypesMap[key] ?? 'EXTERNAL',
                    info: isInjectedConnector ? undefined : { rdns: key },
                    chain: this.namespace,
                    chains: [],
                    provider: this.ethersConfig?.[connector]
                });
            }
        });
    }
    setUniversalProvider(universalProvider) {
        this.addConnector(new WalletConnectConnector({
            provider: universalProvider,
            caipNetworks: this.getCaipNetworks(),
            namespace: 'eip155'
        }));
    }
    eip6963EventHandler(event) {
        if (event.detail) {
            const { info, provider } = event.detail;
            const existingConnector = this.connectors?.find(c => c.name === info?.name);
            if (!existingConnector) {
                const type = PresetsUtil.ConnectorTypesMap[CommonConstantsUtil.CONNECTOR_ID.EIP6963];
                const id = info?.rdns || info?.name || info?.uuid;
                if (type && this.namespace && id) {
                    this.addConnector({
                        id,
                        type,
                        imageUrl: info?.icon,
                        name: info?.name || 'Unknown',
                        provider,
                        info,
                        chain: this.namespace,
                        chains: []
                    });
                }
            }
        }
    }
    listenInjectedConnector(enableEIP6963) {
        if (typeof window !== 'undefined' && enableEIP6963) {
            const handler = this.eip6963EventHandler.bind(this);
            window.addEventListener(ConstantsUtil.EIP6963_ANNOUNCE_EVENT, handler);
            window.dispatchEvent(new Event(ConstantsUtil.EIP6963_REQUEST_EVENT));
        }
    }
    async connect({ id, type, chainId }) {
        const connector = this.connectors.find(c => c.id === id);
        const selectedProvider = connector?.provider;
        if (!selectedProvider) {
            throw new Error('Provider not found');
        }
        let accounts = [];
        let requestChainId = undefined;
        if (type === 'AUTH') {
            const { address } = await selectedProvider.connect({
                chainId,
                preferredAccountType: AccountController.state.preferredAccountTypes?.eip155
            });
            this.emit('accountChanged', {
                address: address,
                chainId: Number(chainId)
            });
        }
        else {
            accounts = await selectedProvider.request({
                method: 'eth_requestAccounts'
            });
            requestChainId = await selectedProvider.request({
                method: 'eth_chainId'
            });
            if (requestChainId !== chainId) {
                const caipNetwork = this.getCaipNetworks().find(n => n.id === chainId);
                if (!caipNetwork) {
                    throw new Error('Ethers5Adapter:connect - could not find the caipNetwork to switch');
                }
                try {
                    await this.switchNetwork({
                        caipNetwork,
                        provider: selectedProvider,
                        providerType: type
                    });
                }
                catch (error) {
                    throw new Error('Ethers5Adapter:connect - Switch network failed');
                }
            }
            this.emit('accountChanged', {
                address: accounts[0],
                chainId: Number(chainId)
            });
            this.listenProviderEvents(selectedProvider);
        }
        return {
            address: accounts[0],
            chainId: Number(chainId),
            provider: selectedProvider,
            type: type,
            id
        };
    }
    async getAccounts(params) {
        const connector = this.connectors.find(c => c.id === params.id);
        const selectedProvider = connector?.provider;
        if (!selectedProvider || !connector) {
            throw new Error('Provider not found');
        }
        if (params.id === CommonConstantsUtil.CONNECTOR_ID.AUTH) {
            const provider = connector['provider'];
            if (!provider.user) {
                return { accounts: [] };
            }
            const { accounts, address } = provider.user;
            return Promise.resolve({
                accounts: (accounts || [{ address, type: 'eoa' }]).map(account => CoreHelperUtil.createAccount('eip155', account.address, account.type))
            });
        }
        const accounts = await selectedProvider.request({
            method: 'eth_requestAccounts'
        });
        return {
            accounts: accounts.map(account => CoreHelperUtil.createAccount('eip155', account, 'eoa'))
        };
    }
    async reconnect(params) {
        const { id, chainId } = params;
        const connector = this.connectors.find(c => c.id === id);
        if (connector && connector.type === 'AUTH' && chainId) {
            await connector.provider.connect({
                chainId,
                preferredAccountType: AccountController.state.preferredAccountTypes?.eip155
            });
        }
    }
    async disconnect(params) {
        if (!params.provider || !params.providerType) {
            throw new Error('Provider or providerType not provided');
        }
        switch (params.providerType) {
            case 'WALLET_CONNECT':
                if (params.provider.session) {
                    ;
                    params.provider.disconnect();
                }
                break;
            case 'AUTH':
                await params.provider.disconnect();
                break;
            case 'ANNOUNCED':
            case 'EXTERNAL':
                await this.revokeProviderPermissions(params.provider);
                break;
            default:
                throw new Error('Unsupported provider type');
        }
    }
    async getBalance(params) {
        const address = params.address;
        const caipNetwork = this.getCaipNetworks().find(network => network.id === params.chainId);
        if (!address) {
            return Promise.resolve({ balance: '0.00', symbol: 'ETH' });
        }
        if (caipNetwork) {
            const caipAddress = `${caipNetwork.caipNetworkId}:${address}`;
            const cachedPromise = this.balancePromises[caipAddress];
            if (cachedPromise) {
                return cachedPromise;
            }
            const cachedBalance = StorageUtil.getNativeBalanceCacheForCaipAddress(caipAddress);
            if (cachedBalance) {
                return { balance: cachedBalance.balance, symbol: cachedBalance.symbol };
            }
            const jsonRpcProvider = new ethers.providers.JsonRpcProvider(caipNetwork.rpcUrls.default.http[0], {
                chainId: caipNetwork.id,
                name: caipNetwork.name
            });
            if (jsonRpcProvider) {
                try {
                    this.balancePromises[caipAddress] = new Promise(async (resolve) => {
                        const balance = await jsonRpcProvider.getBalance(address);
                        const formattedBalance = formatEther(balance);
                        StorageUtil.updateNativeBalanceCache({
                            caipAddress,
                            balance: formattedBalance,
                            symbol: caipNetwork.nativeCurrency.symbol,
                            timestamp: Date.now()
                        });
                        resolve({ balance: formattedBalance, symbol: caipNetwork.nativeCurrency.symbol });
                    }).finally(() => {
                        delete this.balancePromises[caipAddress];
                    });
                    return this.balancePromises[caipAddress] || { balance: '0.00', symbol: 'ETH' };
                }
                catch (error) {
                    return { balance: '0.00', symbol: 'ETH' };
                }
            }
        }
        return { balance: '0.00', symbol: 'ETH' };
    }
    listenProviderEvents(provider) {
        const disconnect = () => {
            this.removeProviderListeners(provider);
            this.emit('disconnect');
        };
        const accountsChangedHandler = (accounts) => {
            if (accounts.length > 0) {
                this.emit('accountChanged', {
                    address: accounts[0]
                });
            }
            else {
                disconnect();
            }
        };
        const chainChangedHandler = (chainId) => {
            const chainIdNumber = typeof chainId === 'string' ? EthersHelpersUtil.hexStringToNumber(chainId) : Number(chainId);
            this.emit('switchNetwork', { chainId: chainIdNumber });
        };
        provider.on('disconnect', disconnect);
        provider.on('accountsChanged', accountsChangedHandler);
        provider.on('chainChanged', chainChangedHandler);
        this.providerHandlers = {
            disconnect,
            accountsChanged: accountsChangedHandler,
            chainChanged: chainChangedHandler
        };
    }
    removeProviderListeners(provider) {
        if (this.providerHandlers) {
            provider.removeListener('disconnect', this.providerHandlers.disconnect);
            provider.removeListener('accountsChanged', this.providerHandlers.accountsChanged);
            provider.removeListener('chainChanged', this.providerHandlers.chainChanged);
            this.providerHandlers = null;
        }
    }
    async switchNetwork(params) {
        const { caipNetwork, provider, providerType } = params;
        if (providerType === 'AUTH') {
            await super.switchNetwork(params);
            return;
        }
        try {
            await provider.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: EthersHelpersUtil.numberToHexString(caipNetwork.id) }]
            });
        }
        catch (switchError) {
            if (switchError.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID ||
                switchError.code === WcConstantsUtil.ERROR_INVALID_CHAIN_ID ||
                switchError.code === WcConstantsUtil.ERROR_CODE_DEFAULT ||
                switchError?.data?.originalError?.code === WcConstantsUtil.ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
                await EthersHelpersUtil.addEthereumChain(provider, caipNetwork);
            }
            else if (providerType === 'ANNOUNCED' ||
                providerType === 'EXTERNAL' ||
                providerType === 'INJECTED') {
                throw new Error('Chain is not supported');
            }
        }
    }
    getWalletConnectProvider() {
        return this.connectors.find(c => c.type === 'WALLET_CONNECT')?.provider;
    }
    async revokeProviderPermissions(provider) {
        try {
            const permissions = await provider.request({
                method: 'wallet_getPermissions'
            });
            const ethAccountsPermission = permissions.find(permission => permission.parentCapability === 'eth_accounts');
            if (ethAccountsPermission) {
                await provider.request({
                    method: 'wallet_revokePermissions',
                    params: [{ eth_accounts: {} }]
                });
            }
        }
        catch (error) {
            console.info('Could not revoke permissions from wallet. Disconnecting...', error);
        }
    }
    async getCapabilities(params) {
        const provider = ProviderUtil.getProvider(CommonConstantsUtil.CHAIN.EVM);
        if (!provider) {
            throw new Error('Provider is undefined');
        }
        const walletCapabilitiesString = provider.session?.sessionProperties?.['capabilities'];
        if (walletCapabilitiesString) {
            const walletCapabilities = Ethers5Methods.parseWalletCapabilities(walletCapabilitiesString);
            const accountCapabilities = walletCapabilities[params];
            if (accountCapabilities) {
                return accountCapabilities;
            }
        }
        return await provider.request({ method: 'wallet_getCapabilities', params: [params] });
    }
    async grantPermissions(params) {
        const provider = ProviderUtil.getProvider(CommonConstantsUtil.CHAIN.EVM);
        if (!provider) {
            throw new Error('Provider is undefined');
        }
        return await provider.request({ method: 'wallet_grantPermissions', params });
    }
    async revokePermissions(params) {
        const provider = ProviderUtil.getProvider(CommonConstantsUtil.CHAIN.EVM);
        if (!provider) {
            throw new Error('Provider is undefined');
        }
        return await provider.request({ method: 'wallet_revokePermissions', params: [params] });
    }
    async walletGetAssets(params) {
        const provider = ProviderUtil.getProvider(CommonConstantsUtil.CHAIN.EVM);
        if (!provider) {
            throw new Error('Provider is undefined');
        }
        return await provider.request({
            method: 'wallet_getAssets',
            params: [params]
        });
    }
}
//# sourceMappingURL=client.js.map