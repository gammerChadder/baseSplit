import {
  Address,
  Avatar,
  Badge,
  DEFAULT_QUERY_OPTIONS,
  EthBalance,
  Identity,
  L2ResolverAbi,
  Name,
  Socials,
  background,
  border,
  cn,
  convertReverseNodeToBytes,
  getAddress,
  getAddresses,
  getAttestations,
  getAvatar,
  getBaseDefaultProfilePicture,
  getChainPublicClient,
  getName,
  isBasename,
  normalize,
  useAttestations,
  useAvatar,
  useName
} from "./chunk-7O7S23LV.js";
import "./chunk-VPBPK4BS.js";
import "./chunk-U7P2NEEE.js";
import {
  RESOLVER_ADDRESSES_BY_CHAIN_ID,
  isBase,
  isEthereum
} from "./chunk-W2BDYGEU.js";
import {
  mainnet
} from "./chunk-W4O76CHD.js";
import "./chunk-FKFV6U3K.js";
import "./chunk-GBHARR65.js";
import "./chunk-52G5JAH4.js";
import "./chunk-NXERQML5.js";
import "./chunk-MFCROKER.js";
import {
  useQuery
} from "./chunk-N52X2Y7B.js";
import "./chunk-GIHFJT4Y.js";
import "./chunk-3LYIN2JF.js";
import "./chunk-AVNE4FUI.js";
import "./chunk-ZLUBC7IW.js";
import "./chunk-R3RTZXAG.js";
import "./chunk-RRV55GGF.js";
import {
  require_jsx_runtime
} from "./chunk-5Y4SKFOD.js";
import "./chunk-TCRMNDQ6.js";
import {
  __toESM
} from "./chunk-4CFW2BUT.js";

// node_modules/@coinbase/onchainkit/dist/identity/components/IdentityCard.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function IdentityCard({
  address,
  chain,
  className = "",
  schemaId,
  badgeTooltip
}) {
  return (0, import_jsx_runtime.jsxs)(
    Identity,
    {
      address,
      chain,
      className: cn(
        border.radius,
        border.lineDefault,
        background.default,
        "items-left flex min-w-[300px] p-4",
        className
      ),
      schemaId,
      children: [
        (0, import_jsx_runtime.jsx)(Avatar, {}),
        (0, import_jsx_runtime.jsx)(Name, { children: (0, import_jsx_runtime.jsx)(Badge, { tooltip: badgeTooltip }) }),
        (0, import_jsx_runtime.jsx)(Address, {}),
        (0, import_jsx_runtime.jsx)(Socials, {})
      ]
    }
  );
}

// node_modules/@coinbase/onchainkit/dist/identity/utils/getAvatars.js
var getAvatars = async ({
  ensNames,
  chain = mainnet
}) => {
  if (!ensNames || ensNames.length === 0) {
    return [];
  }
  const chainIsBase = isBase({ chainId: chain.id });
  const chainIsEthereum = isEthereum({ chainId: chain.id });
  const chainSupportsUniversalResolver = chainIsEthereum || chainIsBase;
  if (!chainSupportsUniversalResolver) {
    return Promise.reject(
      "ChainId not supported, avatar resolution is only supported on Ethereum and Base."
    );
  }
  const results = Array(ensNames.length).fill(null);
  const basenameIndices = [];
  ensNames.forEach((name, index) => {
    if (isBasename(name)) {
      basenameIndices.push(index);
    }
  });
  if (chainIsBase && basenameIndices.length > 0) {
    const client = getChainPublicClient(chain);
    try {
      const baseAvatarPromises = basenameIndices.map(
        (index) => client.getEnsAvatar({
          name: normalize(ensNames[index]),
          universalResolverAddress: RESOLVER_ADDRESSES_BY_CHAIN_ID[chain.id]
        }).catch((error) => {
          console.error(
            `Error resolving Base avatar for ${ensNames[index]}:`,
            error
          );
          return null;
        })
      );
      const baseAvatarResults = await Promise.all(baseAvatarPromises);
      baseAvatarResults.forEach((avatar, i) => {
        const originalIndex = basenameIndices[i];
        if (avatar) {
          results[originalIndex] = avatar;
        }
      });
    } catch (error) {
      console.error("Error resolving Base avatars in batch:", error);
    }
  }
  const fallbackClient = getChainPublicClient(mainnet);
  try {
    const ensAvatarPromises = ensNames.map((name, index) => {
      if (results[index] !== null) {
        return Promise.resolve(null);
      }
      return fallbackClient.getEnsAvatar({
        name: normalize(name)
      }).catch((error) => {
        console.error(`Error resolving ENS avatar for ${name}:`, error);
        return null;
      });
    });
    const ensAvatarResults = await Promise.all(ensAvatarPromises);
    ensAvatarResults.forEach((avatar, index) => {
      if (avatar && results[index] === null) {
        results[index] = avatar;
      }
    });
  } catch (error) {
    console.error("Error resolving ENS avatars in batch:", error);
  }
  for (const index of basenameIndices) {
    if (results[index] === null) {
      results[index] = getBaseDefaultProfilePicture(
        ensNames[index]
      );
    }
  }
  return results;
};

// node_modules/@coinbase/onchainkit/dist/identity/utils/getNames.js
var getNames = async ({
  addresses,
  chain = mainnet
}) => {
  if (!addresses || addresses.length === 0) {
    return [];
  }
  const chainIsBase = isBase({ chainId: chain.id });
  const chainIsEthereum = isEthereum({ chainId: chain.id });
  const chainSupportsUniversalResolver = chainIsEthereum || chainIsBase;
  if (!chainSupportsUniversalResolver) {
    return Promise.reject(
      "ChainId not supported, name resolution is only supported on Ethereum and Base."
    );
  }
  const client = getChainPublicClient(chain);
  const results = Array(addresses.length).fill(null);
  if (chainIsBase) {
    try {
      const calls = addresses.map((address) => ({
        address: RESOLVER_ADDRESSES_BY_CHAIN_ID[chain.id],
        abi: L2ResolverAbi,
        functionName: "name",
        args: [convertReverseNodeToBytes(address, chain.id)]
      }));
      const batchResults = await client.multicall({
        contracts: calls,
        allowFailure: true
      });
      const basenamesWithIndices = [];
      for (let index = 0; index < batchResults.length; index++) {
        const result = batchResults[index];
        if (result.status === "success" && result.result) {
          const basename = result.result;
          basenamesWithIndices.push({ basename, index });
        }
      }
      if (basenamesWithIndices.length > 0) {
        try {
          const basenames = basenamesWithIndices.map(
            ({ basename }) => basename
          );
          const resolvedAddresses = await getAddresses({
            names: basenames
          });
          for (let i = 0; i < basenamesWithIndices.length; i++) {
            const { basename, index } = basenamesWithIndices[i];
            const resolvedAddress = resolvedAddresses[i];
            if (resolvedAddress && resolvedAddress.toLowerCase() === addresses[index].toLowerCase()) {
              results[index] = basename;
            }
          }
        } catch (error) {
          console.error(
            "Error during batch basename forward resolution verification:",
            error
          );
        }
      }
      if (results.every((result) => result !== null)) {
        return results;
      }
    } catch (error) {
      console.error("Error resolving Base names in batch:", error);
    }
  }
  const fallbackClient = getChainPublicClient(mainnet);
  const unresolvedIndices = results.map((result, index) => result === null ? index : -1).filter((index) => index !== -1);
  if (unresolvedIndices.length > 0) {
    try {
      const ensPromises = unresolvedIndices.map(
        (index) => fallbackClient.getEnsName({
          address: addresses[index]
        }).catch((error) => {
          console.error(
            `Error resolving ENS name for ${addresses[index]}:`,
            error
          );
          return null;
        })
      );
      const ensResults = await Promise.all(ensPromises);
      const ensNamesWithIndices = [];
      for (let i = 0; i < ensResults.length; i++) {
        const ensName = ensResults[i];
        const originalIndex = unresolvedIndices[i];
        if (ensName) {
          ensNamesWithIndices.push({ ensName, originalIndex });
        }
      }
      if (ensNamesWithIndices.length > 0) {
        try {
          const ensNames = ensNamesWithIndices.map(({ ensName }) => ensName);
          const resolvedAddresses = await getAddresses({
            names: ensNames
          });
          for (let i = 0; i < ensNamesWithIndices.length; i++) {
            const { ensName, originalIndex } = ensNamesWithIndices[i];
            const resolvedAddress = resolvedAddresses[i];
            if (resolvedAddress && resolvedAddress.toLowerCase() === addresses[originalIndex].toLowerCase()) {
              results[originalIndex] = ensName;
            }
          }
        } catch (error) {
          console.error(
            "Error during batch ENS forward resolution verification:",
            error
          );
        }
      }
    } catch (error) {
      console.error("Error resolving ENS names in batch:", error);
    }
  }
  return results;
};

// node_modules/@coinbase/onchainkit/dist/identity/hooks/useAddress.js
var useAddress = ({ name, chain = mainnet }, queryOptions) => {
  const queryKey = ["useAddress", name, chain.id];
  return useQuery({
    queryKey,
    queryFn: () => getAddress({ name }),
    enabled: !!name,
    ...DEFAULT_QUERY_OPTIONS,
    // Use cacheTime as gcTime for backward compatibility
    gcTime: queryOptions == null ? void 0 : queryOptions.cacheTime,
    ...queryOptions
  });
};

// node_modules/@coinbase/onchainkit/dist/identity/hooks/useAddresses.js
var useAddresses = ({ names }, queryOptions) => {
  const namesKey = names.join(",");
  const queryKey = ["useAddresses", namesKey];
  return useQuery({
    queryKey,
    queryFn: () => getAddresses({ names }),
    enabled: !!names.length,
    ...DEFAULT_QUERY_OPTIONS,
    // Use cacheTime as gcTime for backward compatibility
    gcTime: queryOptions == null ? void 0 : queryOptions.cacheTime,
    ...queryOptions
  });
};

// node_modules/@coinbase/onchainkit/dist/identity/hooks/useAvatars.js
var useAvatars = ({ ensNames, chain = mainnet }, queryOptions) => {
  const namesKey = ensNames.join(",");
  const queryKey = ["useAvatars", namesKey, chain.id];
  return useQuery({
    queryKey,
    queryFn: () => getAvatars({ ensNames, chain }),
    enabled: !!ensNames.length,
    ...DEFAULT_QUERY_OPTIONS,
    gcTime: queryOptions == null ? void 0 : queryOptions.cacheTime,
    ...queryOptions
  });
};

// node_modules/@coinbase/onchainkit/dist/identity/hooks/useNames.js
var useNames = ({ addresses, chain = mainnet }, queryOptions) => {
  const addressesKey = addresses.join(",");
  const queryKey = ["useNames", addressesKey, chain.id];
  return useQuery({
    queryKey,
    queryFn: () => getNames({ addresses, chain }),
    enabled: !!addresses.length,
    ...DEFAULT_QUERY_OPTIONS,
    // Use cacheTime as gcTime for backward compatibility
    gcTime: queryOptions == null ? void 0 : queryOptions.cacheTime,
    ...queryOptions
  });
};
export {
  Address,
  Avatar,
  Badge,
  EthBalance,
  Identity,
  IdentityCard,
  Name,
  Socials,
  getAddress,
  getAddresses,
  getAttestations,
  getAvatar,
  getAvatars,
  getName,
  getNames,
  isBasename,
  useAddress,
  useAddresses,
  useAttestations,
  useAvatar,
  useAvatars,
  useName,
  useNames
};
//# sourceMappingURL=@coinbase_onchainkit_identity.js.map
